{"name":"Curlcpp","tagline":"An object oriented C++ wrapper for CURL","body":"curlcpp\r\n=======\r\n\r\nAn object-oriented C++ wrapper for cURL tool\r\n\r\nIf you want to know a bit more about cURL, you should go on the official website and read about the three interfaces that curl implements: http://curl.haxx.se/\r\n\r\nCompile and link\r\n================\r\n\r\nStandalone\r\n----------\r\n\r\n```bash\r\ncd build\r\ncmake ..\r\nmake # -j2\r\n```\r\n\r\n**Note:** cURL >= 7.28 is required.\r\n\r\nThen add `<curlcpp root>/build/src/` to your library path and `<curlcpp root>/include/` to your include path.\r\n\r\nWhen linking, link against `curlcpp` (e.g.: g++ -std=c++11 example.cpp -o example -lcurlcpp -lcurl).\r\nOr if you want run from terminal,\r\n\r\ng++ -std=c++11 example.cpp -L/home/arun/path/to/build/src/ -I/home/arun/path/to/include/ -lcurlcpp -lcurl \r\n\r\n\r\nSubmodule\r\n---------\r\n\r\nWhen using a git submodule and CMake-buildsystem, add the following lines to your `CMakeLists.txt`:\r\n\r\n```\r\nADD_SUBDIRECTORY(ext/curlcpp) # Change `ext/curlcpp` to a directory according to your setup\r\nINCLUDE_DIRECTORIES(${CURLCPP_SOURCE_DIR}/include)\r\n```\r\n\r\nBiicode support\r\n===============\r\n\r\nYes, it's avaiable thanks to @qqiangwu! :)\r\n\r\nSimple usage example\r\n====================\r\n\r\nHere's an example of a simple HTTP request to get google web page, using the curl_easy interface:\r\n\r\n`````c++\r\n#include \"curl_easy.h\"\r\n\r\nusing curl::curl_easy;\r\n\r\nint main(int argc, const char **argv) {\r\n    curl_easy easy;\r\n    // Add some option to the curl_easy object.\r\n    easy.add<CURLOPT_URL>(\"http://www.google.it\");\r\n    easy.add<CURLOPT_FOLLOWLOCATION>(1L);\r\n    try {\r\n        // Execute the request.\r\n        easy.perform();\r\n    } catch (curl_easy_exception error) {\r\n        // If you want to get the entire error stack we can do:\r\n        curlcpp_traceback errors = error.get_traceback();\r\n        // Otherwise we could print the stack like this:\r\n        error.print_traceback();\r\n        // Note that the printing the stack will erase it\r\n    }\r\n    return 0;\r\n}\r\n`````\r\n\r\nHere's instead, the creation of an HTTPS POST login form:\r\n\r\n`````c++\r\n#include \"curl_easy.h\"\r\n#include \"curl_form.h\"\r\n\r\nusing curl::curl_form;\r\nusing curl::curl_easy;\r\n\r\nint main(int argc, const char * argv[]) {\r\n    curl_form form;\r\n    curl_easy easy;\r\n    // Forms creation\r\n    curl_pair<CURLformoption,string> name_form(CURLFORM_COPYNAME,\"user\");\r\n    curl_pair<CURLformoption,string> name_cont(CURLFORM_COPYCONTENTS,\"you username here\");\r\n    curl_pair<CURLformoption,string> pass_form(CURLFORM_COPYNAME,\"passw\");\r\n    curl_pair<CURLformoption,string> pass_cont(CURLFORM_COPYCONTENTS,\"your password here\");\r\n    \r\n    try {\r\n    \t// Form adding\r\n        form.add(name_form,name_cont);\r\n        form.add(pass_form,pass_cont);\r\n        \r\n        // Add some options to our request\r\n        easy.add<CURLOPT_URL>(\"your url here\");\r\n        easy.add<CURLOPT_SSL_VERIFYPEER>(false);\r\n        easy.add<CURLOPT_HTTPPOST>(form);\r\n        // Execute the request.\r\n        easy.perform();\r\n    } catch (curl_easy_exception error) {\r\n        // If you want to get the entire error stack we can do:\r\n        curlcpp_traceback errors = error.get_traceback();\r\n        // Otherwise we could print the stack like this:\r\n        error.print_traceback();\r\n        // Note that the printing the stack will erase it\r\n    }\r\n    return 0;\r\n}\r\n`````\r\n\r\nAnd if we would like to put the returned content in a file? Nothing easier than:\r\n\r\n`````c++\r\n#include <iostream>\r\n#include \"curl_easy.h\"\r\n#include <fstream>\r\n\r\nusing std::cout;\r\nusing std::endl;\r\nusing std::ofstream;\r\nusing curl::curl_easy;\r\n\r\nint main(int argc, const char * argv[]) {\r\n    // Create a file\r\n    ofstream myfile;\r\n    myfile.open (\"Path to your file\");\r\n    \r\n    // Create a curl_ios object to handle the stream\r\n    curl_ios<ostream> writer(myfile);\r\n    // Pass it to the easy constructor and watch the content returned in that file!\r\n    curl_easy easy(writer);\r\n    \r\n    // Add some option to the easy handle\r\n    easy.add<CURLOPT_URL>(\"http://www.google.it\");\r\n    easy.add<CURLOPT_FOLLOWLOCATION>(1L);\r\n    try {\r\n        // Execute the request\r\n        easy.perform();\r\n    } catch (curl_easy_exception error) {\r\n        // If you want to get the entire error stack we can do:\r\n        curlcpp_traceback errors = error.get_traceback();\r\n        // Otherwise we could print the stack like this:\r\n        error.print_traceback();\r\n        // Note that the printing the stack will erase it\r\n    }\r\n    myfile.close();\r\n    return 0;\r\n}\r\n`````\r\n\r\nNot interested in files? So let's put the request's output in a variable!\r\n\r\n`````c++\r\n#include \"curl_easy.h\"\r\n#include \"curl_form.h\"\r\n\r\nusing curl::curl_easy;\r\n\r\nint main() {\r\n    // Create a stringstream object\r\n    ostringstream str;\r\n    // Create a curl_ios object, passing the stream object.\r\n    curl_ios<ostringstream> writer(str);\r\n    \r\n    // Pass the writer to the easy constructor and watch the content returned in that variable!\r\n    curl_easy easy(writer);\r\n    // Add some option to the easy handle\r\n    easy.add<CURLOPT_URL>(\"http://www.google.it\");\r\n    easy.add<CURLOPT_FOLLOWLOCATION>(1L);\r\n    try {\r\n        // Execute the request.\r\n        easy.perform();\r\n    } catch (curl_easy_exception error) {\r\n        // If you want to get the entire error stack we can do:\r\n        curlcpp_traceback errors = error.get_traceback();\r\n        // Otherwise we could print the stack like this:\r\n        error.print_traceback();\r\n        // Note that the printing the stack will erase it\r\n    }\r\n    // Let's print the stream content.\r\n    cout<<str.str()<<endl;\r\n    return 0;\r\n}\r\n`````\r\n\r\nI have implemented a sender and a receiver to make it easy to use send/receive without handling\r\nbuffers. For example, a very simple send/receiver would be:\r\n\r\n`````c++\r\n#include \"curl_easy.h\"\r\n#include \"curl_form.h\"\r\n#include \"curl_pair.h\"\r\n#include \"curl_receiver.h\"\r\n#include \"curl_sender.h\"\r\n\r\nusing curl::curl_form;\r\nusing curl::curl_easy;\r\nusing curl::curl_sender;\r\nusing curl::curl_receiver;\r\n\r\nint main(int argc, const char * argv[]) {\r\n    // Simple request\r\n    string request = \"GET / HTTP/1.0\\r\\nHost: example.com\\r\\n\\r\\n\";\r\n    // Creation of easy object.\r\n    curl_easy easy;\r\n    try {\r\n        easy.add<CURLOPT_URL>(\"http://example.com\");\r\n        // Just connect\r\n        easy.add<CURLOPT_CONNECT_ONLY>(true);\r\n        // Execute the request.\r\n        easy.perform();\r\n    } catch (curl_easy_exception error) {\r\n        // If you want to get the entire error stack we can do:\r\n        curlcpp_traceback errors = error.get_traceback();\r\n        // Otherwise we could print the stack like this:\r\n        error.print_traceback();\r\n        // Note that the printing the stack will erase it\r\n    }\r\n    \r\n    // Creation of a sender. You should wait here using select to check if socket is ready to send.\r\n    curl_sender<string> sender(easy);\r\n    sender.send(request);\r\n    // Prints che sent bytes number.\r\n    cout<<\"Sent bytes: \"<<sender.get_sent_bytes()<<endl;\r\n    for(;;) {\r\n        // You should wait here to check if socket is ready to receive\r\n        try {\r\n            // Create a receiver\r\n            curl_receiver<char,1024> receiver;\r\n            // Receive the content on the easy handler\r\n            receiver.receive(easy);\r\n            // Prints the received bytes number.\r\n            cout<<\"Receiver bytes: \"<<receiver.get_received_bytes()<<endl;\r\n        } catch (curl_easy_exception error) {\r\n            // If any errors occurs, exit from the loop\r\n            break;\r\n        }\r\n    }\r\n    return 0;\r\n}\r\n`````\r\n","google":"UA-64151023-2","note":"Don't delete this file! It's used internally to help with page regeneration."}